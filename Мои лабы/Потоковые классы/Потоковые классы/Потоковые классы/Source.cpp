// Потоковые классы - ОО вариант функции ANSI-C (ввода и вывода)
//		Свойства:
//			1)объект потокового класса может быть как источником, так и приемником данных
//			2)потоки используется для ввода-вывода высокого уровня
//		    3)Каждый потоковый класс предоставляет буферный объект для хранения данных низкого уровня
// 
//		Виды потоковых классов:
//		1)istream, ostream - общие потоковые классы, могут быть связаны с любым буферным объектом
//		2)ifstream ofstream - потоковые классы для файлов
//		3)istringstream, ostringstream - потоковые классы для объектов строк
//
//		Библиотека потоковых классов С++ построена на двух базовых классах: ios и streambuf
//		streambuf - обеспечивает взаимосвязь буферов ввода и вывода
//		ios - содержит методы для форматирования данных ввода и вывода и проверки ошибок
//
//		Стандартные потоки ввода и вывода:
//		1)cin
//		2)cout
//		3)cerr
//		4)clog
// 
//		Форматирование ввода-вывода (перегрузка операторов ввода и вывода):
//		1)Флаги форматирования
//		2)Манипуляторы
// 
//		Флагами форматирования называется набор определений enum перечисляемого типа в классе ios
//		Они работают переключателями, определяющими различные форматы и способы ввода и вывода
//		
//		Для установки флагов форматирования в С++ есть 2 способа:
//		1)С помощью функции
//		-Функция setf: синтаксис: cout.setf(ios::flag); <-- Добавляет к набору флагов потока указанный флаг
//		-Функция unsetf: синтаксис: cout.unsetf(ios::flag); <-- снимает значение переданного ей флага
//		2)С помощью манипуляторов
//		-Манипулятор setiosflags - устанавливает значения переданных ему флагов для потока,
//		 в который он выводится или из которого вводится
//		-Манипулятор resetiosflags - делает все наоборот
// 	
//		
//		Манипулятор - инструкции форматирования, которые вставляются прямо в поток. Например endl
//		Для использования манипуляторов необходимо подключить <iomanip>
//
//		Некоторые манипуляторы имеют требуемое значение на ввод
//		Пример: cout << setw(10) << "123";
//		Манипуляторы - что-то вроде фильтров, значение, проходя через них меняет свой вид
//		Флаги форматирования находятся в классе std::ios_base
//		Методы, отвечающие за ввод и вывод std::istream
// 
//		Пользовательские манипуляторы
//		Синтаксис ввода с параметрами:
//		ofstream& имя_манипулятора(ostream& поток)
//		{
//			//Код манипулятора
//			return поток;
//		}
//
//		cout << имя_манипулятора << данные;
// 
//		Синтаксис ввода без параметров:
//		istream& имя_манипулятора(istream& поток)
//		{
//		//код
//		return поток;
//		}
// 
//		cin >> имя_манипулятора >> i;
// 
//		Зачем использовать манипуляторы?
//		-устройству, например принтеру, может понадобиться манипулятор,
//		если необходимо вывести или ввести данные на необычном оборудовании
//		-Для объединения последовательности нескольких отдельных операций
//		по вводу или выводу в одну операцию
//		
//		Состояние потока:
//		каждый поток имеет свое состояние. Его состояние можно получить с помощью
//		функции rdstate(), которая возвращает тип int
//		goodbit = 0 - нет ошибки
//		eofbit = 1 - конец потока
//		failbit = 2 - последняя операция не выполнилась
//		badbit = 4 - попытка использования недопустимой операции
//		hardfail = 8 - фатальная ошибка
// 
//		stream.rdstate() <--- объект-ifstream.функция()
// 
//		Состояние потока можно проверить с помощью функции:
//		bad(); - возвращает 1, если hardfail или batbit
//		fail() - возвращает 1, если hardbit и hardfail
//		eof(); - возвращает 1, если eofbit
//		good() - возвращает 1, если eofbit
// 
//		stream.fail();	//bool false
//		stream.good(); //bool true
// 
//		Неформатированный ввод:
//		Синтаксис:
//		get(char* buffer, int size, char delimiter = '\n);  - копирует файл в буфер, считывает до определенного символа или до заполнения буфера
//		get(char C); - считывает 1 символ из потока
// 
//		file.get(buffer, 100, ' ');  //Считывает данные до пробела или до пробела
// 
//		При повторном вызове функции, функция начинает работу с последнего своего места
// 
//		getline(char* buffer, int size, char delimiter = '\n' - работает как get, но в буфер не отправляет разделитель
//		gcount() - возвращает кол-во символов с последнего считывания
//		putback(C) - в поток помещается символ C
//		ignore(int count = 1) - Функция игнорирует count символов
// 
//		Неформатированный вывод:
//		ofstream& put(char C) - добавляет символ в поток
//		ofstream& write(const char* buffer, int size) - записывает size символов из начала из buffer в выходной поток
//		--> qwerty -->> qweqwerty (если cout.write(buffer,3);
// 
//		Файловый ввод-вывод:
//		конструктор fstream(const char* name_file, int mode);
//		режимы открытия:
//		ios::in - чтение
//		ios::out - перезаписывание
//		ios::ate - после открытия файла перемещает указатель в конец
//		ios::app - дозапись
//		ios::binary - открытие бинарного файла
// 
//		Синтаксис:
//		fstream file("example.txt", ios::in | ios::out);
//		
//		Проверка файлового потока if(имя_файла) - bool тип
//		
//		Присоединение потока:
//		Файл присоединяется к потоку с помощью функции open()
//		fstream stream;  <-- создание потока
//		stream.open("someFile.dat",ios::in | ios::out);
//		stream.close();
// 
//		Устранение ошибок в потоке:
//		Использовать функцию clear()
//		stream.clear();
//		Начать читать файл с начала можно с помощью seekg()
//		stream.seekg(0);
//	 
//		system("color F0");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
